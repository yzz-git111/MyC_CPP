#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	//利用指针遍历一维数组 （同一个数组的地址是连续的！）
	int a[5] = { 8,5,3,12,7 };
	int* p = a; //或者int *p = &a[0]  但是不可以int *p = &a[],因为&a表示的是数组指针
	printf("%p,%p,%p,%p,%p\n", p, p + 1, p + 2, p + 3, p + 4);
	printf("%p,%p,%p,%p,%p\n", &a[0], &a[1], &a[2], &a[3], &a[4]); //验证地址是否相同


	int i = 0;
	for (i; i <= 4; i++)
	{
		printf("%d  ", *(p + i)); //若不加（）即*p+i 表示取p指向的地址的变量+i。但也可以写成*p++ 后置++优先级比*高
	}
	printf("\n");

	//下标运算   先读取地址，再对地址做操作
	*(p + 2) = 23;
	printf("%d\n", a[2]);
	//数组的本质就是 地址+[偏移量]。如a[2]表示a(即数组的首地址)+2个偏移量
	printf("%d\n", p[3]);	//就等于a[3].因为p指向了a，那么p也可以和数组a一样使用下标运算
							//但是需要的条件是一段连续的空间，而数组却刚好满足了这一条件	
	
	printf("%d,%d,%d,%d\n", a[4], p[4], *(a + 4), *(p + 4));
		//p指向a（a==&a[0]）后 以上索引均可以。但是不能使用a++，因为a是地址，是一个常量
											//而p可以p++,因为p是指针，p++表示指向下一地址

	printf("%d,%d\n", 2[p], 2[a]);  //甚至可以写成这样，本质都是下标运算（对指向的地址进行移位）

	int b[4][5] = { {9,6,7,22,4},{11,4,6,7,2},{11,16,45,24,21},{1,2,3,4,5}};
	
	//int* q = &b[0]; //初始化”:“int *”与“int (*)[5]”的间接级别不同
	int* q = &b[0][0];  //虽然&b[0]==&b[0][0]  但是用*q指向&b[0]时 &b[0]是一个数组指针

	int c = *((q + 2) + 3); //q指向了二维数组b的首地址&b[0][0],q+2变为地址&b[0][2],再+3变成了地址&b[1][0]
	printf("%d", c);

	return 0;
}